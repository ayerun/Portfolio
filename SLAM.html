<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>SLAM</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
        <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script type="text/javascript" id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
        </script>
        <script>
        window.MathJax = {
            tex: {
              tags: 'ams'
            }
          };
        </script>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li class="active"><a href="index.html">Projects</a></li>
							<li><a href="about.html">About</a></li>
							<li><a href="contact.html">Contact</a></li>
							<li><a href="Resume_Kumar.pdf" target="_blank" download>Resume</a></li>
						</ul>
						<ul class="icons">
							<li><a href="https://www.linkedin.com/in/arun-kumar-102197/" target="_blank" class="icon brands alt fa-linkedin"><span class="label">Linkedin</span></a></li>
							<li><a href="https://github.com/ayerun" target="_blank" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">January 2021 - March 2021</span>
									<h1>Differential Drive & SLAM from Scratch</h1>
                                    <p>Wrote all software for differential drive with (dead reckoning) odometry. Then, implemented an extended kalman filter for SLAM.</p>
                                </header>
                                
                                <div class="image main"><img src="images/slam_cropped.png" alt="" /></div>
                                
								<h2>Overview</h2>
								<p> In this project, I took a Turtlebot3 Burger and removed all the preinstalled ROS software. 
                                    Then, I wrote, tested, and implemented my own C++ scripts for 2D transformations, differential drive, odometry, and SLAM. 
                                    This project served as a learning experience in ROS/C++ and demonstrates my knowledge of robotic software development.
                                    The only robotic software in this project that I did not code myself is the C code controlling the motors and lidar.<br/>
                                    -insert gif of turtlebot-
                                </p>

                                <h2>Setup</h2>
                                <h4>Robot Visualization</h4>
                                <p> I started this project by creating a ROS package (-insert link-) for robot visualization in Rviz. 
                                    This was the first step in the simulation process. 
                                    It was imperative to test my software in simulation prior to deploying new features onto the physical robot. 
                                    The controlled simulation environment simplifies the process of finding a correcting errors in my code. 
                                    This ROS package utilizes the URDF files written by the TurtleBot manufacturer to display the Robot in Rviz.<br/>
                                    -insert rviz pic-
                                </p>
								<h4>2D Tranformations</h4>
                                <p> Due to the math involved in differential drive and odometry, I decided to write a C++ library (-insert rigid2d link-) for 2D transformations. 
                                    The library provides data structures for 2D transformations, vectors, and twists.
                                    I wrote standard operator overload methods for addition, subtraction, and multiplication as well as methods for applying transformations to vectors and twists.
                                    The library was heavily tested (-insert link-). It serves as the backbone to all the software a created from this point.
								</p>

								<h2>Kinematics</h2>
								<p> Differential drive robots are controlled by a twist representing body velocity and angular velocity. 
                                    This means to control the robot, I needed to calculate the wheel velocities that achieve the desired twist. 
                                    I used the following diagram to derive the relationship between wheel velocities and body twist.
                                </p>
                                    <img class="image center" src="images/kinematics.jpg" alt="" /><br/>
                                    <div class="align center">
                                        <p class="image center"><b>Figure 1.</b> 
                                            Reference frames for TurtleBot. X axes are in red and y axes are in greed. 
                                            Frame b is the body, r is the right wheel, and l is the left wheel.
                                        </p>
                                    </div>
                                <p>
                                    To start the derivation, I wrote the transformation matricies from the body to the wheels.<br/>
                                    $$T_{bl} = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & D \\ 0 & 0 & 1 \end{bmatrix} \hspace{10mm}
                                    T_{br} = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & -D \\ 0 & 0 & 1 \end{bmatrix}$$

                                    Then, I wrote the adjoint matricies between the body and wheels.<br/>
                                    $$A_{bl} = \begin{bmatrix} 1 & 0 & 0\\ D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \hspace{10mm}
                                    A_{br} = \begin{bmatrix} 1 & 0 & 0\\ -D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$$
                                    $$A_{lb} = \begin{bmatrix} 1 & 0 & 0\\ -D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \hspace{10mm}
                                    A_{rb} = \begin{bmatrix} 1 & 0 & 0\\ D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$$

                                    The following equation is used to relate twist in the wheel frame to the control.<br/>
                                    $$\begin{bmatrix} \dot{x_i} \\ \dot{y_i} \end{bmatrix} = \begin{bmatrix} r\dot{&phi;}_i \\ 0 \end{bmatrix}$$
                                    r is the wheel radius<br/>
                                    \(\dot{&phi;}\) is the rotational velocity<br/>
                                    i is the wheel (l or r in this case)<br/><br/>

                                    Now, I can rewrite the body twist in the wheel frames.<br/>
                                    $$V_b = \begin{bmatrix} \dot{&theta;} \\ \dot{x} \\ \dot{y} \end{bmatrix} \hspace{10mm}
                                    V_i = \begin{bmatrix} \dot{&theta;} \\ r\dot{&phi;}_i \\ 0 \end{bmatrix}$$

                                    Since I am calculating controls, I want to solve for \(\dot{&phi;}_i\) in terms of D, r, \(\dot{&theta;}\), and \(\dot{x}\). 
                                    I used the following relationships to do so.<br/>
                                    $$V_l = A_{lb}V_b$$
                                    $$\begin{bmatrix} \dot{&theta;} \\ r\dot{&phi;}_l \\ 0 \end{bmatrix} = 
                                    \begin{bmatrix} 1 & 0 & 0\\ -D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}
                                    \begin{bmatrix} \dot{&theta;} \\ \dot{x} \\ \dot{y} \end{bmatrix}$$
                                    $$\begin{equation} \mathbf{\dot{&phi;}_l = \frac{-D\dot{&theta;}+\dot{x}}{r}} \end{equation}$$
                                    <br/>
                                    $$V_r = A_{rb}V_b$$
                                    $$\begin{bmatrix} \dot{&theta;} \\ r\dot{&phi;}_r \\ 0 \end{bmatrix} = 
                                    \begin{bmatrix} 1 & 0 & 0\\ D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}
                                    \begin{bmatrix} \dot{&theta;} \\ \dot{x} \\ \dot{y} \end{bmatrix}$$
                                    $$\begin{equation} \mathbf{\dot{&phi;}_r = \frac{D\dot{&theta;}+\dot{x}}{r}} \end{equation}$$

                                    With the rigid2d library, I implemented the kinematics for differential drive in a class called diff_drive (-insert link-).
                                    I wrote a ROS node called fake_turtle (-insert link-) that converts body velocities to wheel controls the publishes the controls.
                                    This allowed me to visualize the code in Rviz.
                                    (-insert gif of wheels moving-)
                                </p>
                                
                                <h2>Odometry</h2>
                                <p> To make the robot move in simulation, I needed to implement odometry. 
                                    There are two ways I could have done this, using IMU or dead reckoning. 
                                    The original TurtleBot software uses IMU which is often inaccurate due to sensor noise.
                                    I decided to use dead reckoning. 
                                    This method uses the change in wheel angles to calculate the robot's location.
                                    It performs best on flat planes with minimal slip.
                                    Since I typically drive the Turtlebot on a wood floor with good traction, this was the obvious choice.
                                    The first step to dead reckoning is obtaining the angular velocities of the wheels.
                                    Using the wheel encoders, I was able to measure the the angular velocities.
                                    Then I calculated the body twist by rearranging equations (1) and (2).
                                    $$V_b = \begin{bmatrix} \dot{&theta;} \\ \dot{x} \\ \dot{y} \end{bmatrix} = 
                                    \begin{bmatrix} \frac{r(\dot{&phi;}_r-\dot{&phi;}_l)}{2D} \\ \frac{r(\dot{&phi;}_r+\dot{&phi;}_l)}{2} \\ 0 \end{bmatrix}$$
                                    The next step is integrating the twist \(V_b\) to find the change in position and orientation \(T_{bb'}\) where {b} is the original body frame and {b'} is the body frame after movement.
								</p>

								<h2>SLAM in Simulation</h2>
								<p>
                                </p>

								<h2>Future Work</h2>
								<p>
                                </p>

                                <h1><a href="https://github.com/ayerun/Robotic_3D_Scanner" target="_blank">-View Full Source Code-</a></h1>
							</section>

					</div>

				<!-- Copyright -->
					<div id="copyright">
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>