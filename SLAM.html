<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>SLAM</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
        <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script type="text/javascript" id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
        </script>
        <script>
        window.MathJax = {
            tex: {
              tags: 'ams'
            }
          };
        </script>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li class="active"><a href="index.html">Projects</a></li>
							<li><a href="about.html">About</a></li>
							<li><a href="contact.html">Contact</a></li>
							<li><a href="Resume_Kumar.pdf" target="_blank" download>Resume</a></li>
						</ul>
						<ul class="icons">
							<li><a href="https://www.linkedin.com/in/arun-kumar-102197/" target="_blank" class="icon brands alt fa-linkedin"><span class="label">Linkedin</span></a></li>
							<li><a href="https://github.com/ayerun" target="_blank" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">January 2021 - March 2021</span>
									<h1>Differential Drive & SLAM from Scratch</h1>
                                    <p>Wrote all software for differential drive with (dead reckoning) odometry. Then, implemented an extended kalman filter for SLAM.</p>
                                </header>
                                
                                <div class="image main"><img src="images/SLAM/slam_cropped.png" alt="" /></div>
                                
								<h2>Overview</h2>
								<p> In this project, I took a Turtlebot3 Burger and removed all the preinstalled ROS software. 
                                    Then, I wrote, tested, and implemented my own C++ scripts for 2D transformations, differential drive, odometry, and SLAM. 
                                    This project served as a learning experience in ROS/C++ and demonstrates my knowledge of robotic software development.
                                    The only robotic software in this project that I did not code myself is the C code controlling the motors and lidar.<br/>
                                    -insert gif of turtlebot-
                                </p>

                                <h2>Setup</h2>
                                <h4>Robot Visualization</h4>
                                <p> I started this project by creating a ROS package (-insert link-) for robot visualization in Rviz. 
                                    This was the first step in the simulation process. 
                                    It was imperative to test my software in simulation prior to deploying new features onto the physical robot. 
                                    The controlled simulation environment simplifies the process of finding a correcting errors in my code. 
                                    This ROS package utilizes the URDF files written by the TurtleBot manufacturer to display the Robot in Rviz.<br/>
                                    -insert rviz pic-
                                </p>
								<h4>2D Tranformations</h4>
                                <p> Due to the math involved in differential drive and odometry, I decided to write a C++ library (-insert rigid2d link-) for 2D transformations. 
                                    The library provides data structures for 2D transformations, vectors, and twists.
                                    I wrote standard operator overload methods for addition, subtraction, and multiplication as well as methods for applying transformations to vectors and twists.
                                    The library was heavily tested (-insert link-). It serves as the backbone to all the software a created from this point.
								</p>

								<h2>Kinematics</h2>
								<p> Differential drive robots are controlled by a twist representing body velocity and angular velocity. 
                                    This means to control the robot, I needed to calculate the wheel velocities that achieve the desired twist. 
                                    I used the following diagram to derive the relationship between wheel velocities and body twist.
                                </p>
                                    <img class="image center" src="images/SLAM/kinematics.jpg" alt="" /><br/>
                                    <div class="align center">
                                        <p class="image center"><b>Figure 1.</b> 
                                            Reference frames for TurtleBot. X axes are in red and y axes are in greed. 
                                            Frame b is the body, r is the right wheel, and l is the left wheel.
                                        </p>
                                    </div>
                                <p>
                                    To start the derivation, I wrote the transformation matricies from the body to the wheels.<br/>
                                    $$T_{bl} = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & D \\ 0 & 0 & 1 \end{bmatrix} \hspace{10mm}
                                    T_{br} = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & -D \\ 0 & 0 & 1 \end{bmatrix}$$

                                    Then, I wrote the adjoint matricies between the body and wheels.<br/>
                                    $$A_{bl} = \begin{bmatrix} 1 & 0 & 0\\ D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \hspace{10mm}
                                    A_{br} = \begin{bmatrix} 1 & 0 & 0\\ -D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$$
                                    $$A_{lb} = \begin{bmatrix} 1 & 0 & 0\\ -D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \hspace{10mm}
                                    A_{rb} = \begin{bmatrix} 1 & 0 & 0\\ D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$$

                                    The following equation is used to relate twist in the wheel frame to the control.<br/>
                                    $$\begin{bmatrix} \dot{x_i} \\ \dot{y_i} \end{bmatrix} = \begin{bmatrix} r\dot{&phi;}_i \\ 0 \end{bmatrix}$$
                                    r is the wheel radius<br/>
                                    \(\dot{&phi;}\) is the rotational velocity<br/>
                                    i is the wheel (l or r in this case)<br/><br/>

                                    Now, I can rewrite the body twist in the wheel frames.<br/>
                                    $$V_b = \begin{bmatrix} \dot{&theta;} \\ \dot{x} \\ \dot{y} \end{bmatrix} \hspace{10mm}
                                    V_i = \begin{bmatrix} \dot{&theta;} \\ r\dot{&phi;}_i \\ 0 \end{bmatrix}$$

                                    Since I am calculating controls, I want to solve for \(\dot{&phi;}_i\) in terms of D, r, \(\dot{&theta;}\), and \(\dot{x}\). 
                                    I used the following relationships to do so.<br/>
                                    $$V_l = A_{lb}V_b$$
                                    $$\begin{bmatrix} \dot{&theta;} \\ r\dot{&phi;}_l \\ 0 \end{bmatrix} = 
                                    \begin{bmatrix} 1 & 0 & 0\\ -D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}
                                    \begin{bmatrix} \dot{&theta;} \\ \dot{x} \\ \dot{y} \end{bmatrix}$$
                                    $$\begin{equation} \mathbf{\dot{&phi;}_l = \frac{-D\dot{&theta;}+\dot{x}}{r}} \end{equation}$$
                                    <br/>
                                    $$V_r = A_{rb}V_b$$
                                    $$\begin{bmatrix} \dot{&theta;} \\ r\dot{&phi;}_r \\ 0 \end{bmatrix} = 
                                    \begin{bmatrix} 1 & 0 & 0\\ D & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}
                                    \begin{bmatrix} \dot{&theta;} \\ \dot{x} \\ \dot{y} \end{bmatrix}$$
                                    $$\begin{equation} \mathbf{\dot{&phi;}_r = \frac{D\dot{&theta;}+\dot{x}}{r}} \end{equation}$$

                                    With the rigid2d library, I implemented the kinematics for differential drive in a class called diff_drive (-insert link-).
                                    I wrote a ROS node called fake_turtle (-insert link-) that converts body velocities to wheel controls the publishes the controls.
                                    This allowed me to visualize the code in Rviz.
                                    (-insert gif of wheels moving-)
                                </p>
                                
                                <h2>Odometry</h2>
                                <p> To make the robot move in simulation, I needed to implement odometry. 
                                    There are two ways I could have done this, using IMU or dead reckoning. 
                                    The original TurtleBot software uses IMU which is often inaccurate due to sensor noise.
                                    I decided to use dead reckoning. 
                                    This method uses the change in wheel angles to calculate the robot's location.
                                    It performs best on flat planes with minimal slip.
                                    Since I typically drive the Turtlebot on a wood floor with good traction, this was the obvious choice.
                                    The first step to dead reckoning is obtaining the angular velocities of the wheels.
                                    Using the wheel encoders, I was able to measure the the angular velocities.
                                    Then I calculated the body twist by rearranging equations (1) and (2).
                                    $$V_b = \begin{bmatrix} \dot{&theta;} \\ \dot{x} \\ \dot{y} \end{bmatrix} = 
                                    \begin{bmatrix} \frac{r(\dot{&phi;}_r-\dot{&phi;}_l)}{2D} \\ \frac{r(\dot{&phi;}_r+\dot{&phi;}_l)}{2} \\ 0 \end{bmatrix}$$
                                    The next step is integrating the twist \(V_b\) to find the change in position and orientation \(T_{bb'}\) where {b} is the original body frame and {b'} is the body frame after movement. 
                                    You could do this using matrix exponentials, but that is computationally expensive. 
                                    In 2D, there are more efficient methods. 
                                    When integrating the twist in 2D, there are two scenarios.<br/><br/>
                                    <b>Sceneraio 1: Translation without Rotation</b><br/>
                                    In the case \(V_b\) has no rotational component, \(T_{bb'}\) is a pure translation determined by the twist.
                                    $$V_b = \begin{bmatrix} 0 \\ \dot{x} \\ \dot{y} \end{bmatrix} \hspace{10mm}
                                    T_{bb'} = \begin{bmatrix} 1 & 0 & \dot{x}\\ 0 & 1 & \dot{y} \\ 0 & 0 & 1 \end{bmatrix}$$
                                    <b>Scenario 2: Translation with Rotation</b><br/>
                                    In the case \(V_b\) has translational and rotational comopnents, the math gets more complicated.
                                    For any two unit vectors (vector a and vector b) on a plane, there is a pure rotation that transforms vector a to vector b.
                                    Finding the center of rotation in the frame aligned with {b} is the first step to integrate the twist. 
                                    I will refer to frame {s} as the frame at the center of rotation in the orientation of frame {b}.
                                    I will refer to frame {s'} as the frame at the center of rotation in the orientation of frame {b'}.
                                    I determined the location of frame {s} using the adjoint. 
                                    $$\begin{bmatrix} 1 & 0 & 0\\ y_{s} & 1 & 0 \\ -x_{s} & 0 & 1 \end{bmatrix}
                                    \begin{bmatrix} &Delta; &theta; \\ &Delta; x_{b} \\ &Delta; y_{b} \end{bmatrix} = 
                                    \begin{bmatrix} \dot{&theta;} \\ 0 \\ 0 \end{bmatrix}$$
                                    Solving for \(x_{s}\) and \(y_{s}\) gives you \(T_{bs}\)
                                    $$T_{bs} = \begin{bmatrix} 1 & 0 & x_{s} \\ 0 & 1 & y_{s} \\ 0 & 0 & 1 \end{bmatrix}$$
                                    Next, I determined Tss' which is a pure rotation.
                                    $$T_{ss'} = \begin{bmatrix} \cos{\dot{&theta;}} & -\sin{\dot{&theta;}} & 0 \\ \sin{\dot{&theta;}} & \cos{\dot{&theta;}} & 0 \\ 0 & 0 & 1 \end{bmatrix}$$
                                    The last piece was determining \(T_{s'b'}\).
                                    Because frame {s} is the center of rotation between frame {b} and frame {b'}, we can think of frame {s} as the center of a circle with frames {b} and {b'} on the circle's circumference.
                                    Because frame {s} is oriented with {b} and frame {s'} is oriented with {b'}, \(T_{bs} = T_{s'b'}\). Finally, to solve for \(T_{bb'}\) we can use the following equation.
                                    $$T_{bb'} = T_{bs}T_{ss'}T_{s'b'}$$
                                    Now that we characterized all robotic movements, we need to track the robot. This step is simple. 
                                    \(T_{wb}\) is the transformation from the world frame to the robot. 
                                    \(T_{bb'}\) is calculated everytime the robot moves. 
                                    To update the robots location, I used the following equation everytime the robot moved.
                                    $$T_{wb'} = T_{wb}T_{bb'}$$
                                    $$T_{wb} = T_{wb'}$$
                                    -insert odometry experiments-
								</p>

								<h2>SLAM in Simulation</h2>
								<p>At this point in the project, I am able to teleoperate the TurtleBot and accurately track its location. 
                                    This is the framework for the real challenge in this project, SLAM using and Extended Kalman Filter (EKF). 
                                    To simplify the SLAM problem, I am using 10 cylindrical landmarks of equal radius. 
                                    I will use these landmarks for robot localization. 
                                    The robot will only be trained to use these landmarks in the EKF. 
                                </p>
                                <img class="image center" src="images/SLAM/SLAM_Pipeline.svg" alt="" />
                                <div class="align center">
                                    <p class="image center"><b>Figure x.</b> 
                                        SLAM pipeline. Lidar data is the input. 
                                        Circle regression determines which data are landmarks. 
                                        Data association matches circles found in the lidar data with initialized landmarks from SLAM. 
                                        The associated data is then used the refine the SLAM estimate.
                                    </p>
                                </div>
                                <p>To simplify the software developement required for SLAM. I started with SLAM in Simulation.
                                    This allowed me to develop and test the EKF prior to attempting circle regression and data association.
                                </p>

								<h2>Future Work</h2>
								<p>
                                </p>

                                <h1><a href="https://github.com/ayerun/Robotic_3D_Scanner" target="_blank">-View Full Source Code-</a></h1>
							</section>

					</div>

				<!-- Copyright -->
					<div id="copyright">
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>